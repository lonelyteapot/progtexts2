.. highlight:: python

Циклы
=====

В программах довольно часто встречается необходимость повторить
некоторое действие несколько раз. Часто вы даже не знаете заранее,
сколько именно раз. Для этого существует специальная конструкция,
команда языка — цикл.

В питоне есть циклы двух типов.

(Я тут буду приводить примеры кодов. Конечно, экспериментируйте с ними
для лучшего понимания.)

Цикл while
----------

Цикл while — это простейший вариант цикла. Он выполняет некоторые
действия, после чего определяет, не надо ли их выполнить еще раз.
"Определяет" путем проверки указанного программистом условия. Выглядит
код так:

::

    while условие:
        код

Здесь ``условие`` — это условие в том же виде, в котором вы пишете
условие ``if``'а. Там могут быть сравнения, ``and``, ``or`` и т.д.

А ``код`` — это произвольная последовательность комад (может занимать и
несколько строк), содержащая любые команды, которые вы знаете или
узнаете потом: присваивания, if'ы, даже другие циклы и т.д.

Что будет делать компьютер, когда дойдет до такого цикла? Сначала он
проверит, выполняется ли условие. Если выполняется, то компьютер
выполнит указанный код и опять проверит условие. Если оно все еще
выполняется, то компьютер выполнит этот код еще раз, и так далее, до тех
пор, пока при очередной проверке не окажется, что условие не
выполняется. Тогда компьютер закончит выполнение цикла и перейдет к
коду, написанному после него.

Как может ``условие`` выполняться-выполняться, и вдруг перестать
выполняться? Очень просто: ``код`` может изменить какие-то переменные,
из-за которых условие перестанет выполняться. Собственно, в этом и
состоит весь смысл процесса. (А если ``код`` ничего такого не меняет, то
``условие`` будет выполняться всегда, и получится "бесконечный цикл" —
программа зависнет. Не делайте так.)

В частности, может быть так, что условие цикла не будет выполняться с
самого начала. Тогда цикл не выполнится ни разу, исполнение сразу
перейдет на команды после цикла.

Слово "while" переводится как "пока", т.е. вся запись цикла по сути
обозначает "пока выполняется ``условие``, делай ``код``".

Примеры
~~~~~~~

::

    n = int(input())
    a = 1
    while 2 * a < n:
        print(a)
        a += 1
    print("Done")

Что делает этот код? Он сначала считывает с клавиатуры значение ``n``.
Пусть для примера пользователь вводит число 5. Далее в переменную ``a``
записывается 1. А дальше начинается цикл.

Сначала компьютер проверяет, правда ли, что ``2 * a < n``.
Действительно, ``2*a`` равно 2, а ``n`` равно 5, условие выполняется.
Поэтому начинаем выполнять тот код, который написан внутри цикла. А
именно, выводим на экран ``a``, т.е. 1. И прибавляем единицу к ``a``,
получается ``a==2``. Код (говорят "тело цикла") закончился, поэтому
проверяем условие еще раз. Оно все еще выполняется (``2*a`` равно 4, а
``n`` равно 5), поэтому выполняем тело цикла заново. Выводим на экран 2
и увеличиваем ``a`` еще на единицу. Проверяем условие еще раз, оно уже
не выполняется (``2*a`` равно 6, а ``n`` равно 5), цикл закончился.

Цикл закончился, поэтому переходим на то, что после цикла — выводим на
экран Done.

Еще один пример, уже довольно навороченный:

::

    n = int(input())
    a = 1
    while a < n:
        b = a
        while b > 0:
            if b % 2 == 1:
                print(b, end=" ")
            b -= 1
        print()
        a *= 2

Здесь цикл, вложенный в цикл. Это работает следующим образом. Пусть
пользователь ввел 6. Переменная ``a`` становится равна 1.

Начинается внешний цикл (который ``while a < n``). Переменная ``b``
становится равна ``a``, т.е. 1. Пока ``b>0`` мы делаем следующее
(внутренний цикл): если ``b`` нечетное, то выводим на экран 1, после
чего уменьшаем ``b`` на 1. В итоге на экран выведется 1, после чего
``b`` станет равно 0, и внутренний цикл закончится.

Но внешний цикл еще продолжается. Выполняется команда ``print()``,
которая просто переводит строку, и переменная ``a`` увеличивается в 2
раза и становится равна 2. Проверяем условие цикла: ``a`` все еще меньше
``n``. Поэтому повторяем операции, но уже с новым ``a``. Переменная
``b`` становится равна 2, начинается внутренний цикл, сначала (при
``b==2``) на экран ничего не выводится (т.к. ``b`` четное), и ``b``
становится равно 1, потом на экран выводится 1, и ``b`` становится равно
0 и внутренний цикл заканчивается.

Продолжается внешний цикл, выводится перевод строки и ``a`` становится
равно 4. Это все еще меньше чем ``n``, поэтому входим заново во
внутренний цикл, ``b`` становится равно 4 ... и за весь внутренний цикл
на экран выводится 3 1 (я не буду уже подробно расписывать).

Далее опять выводим перевод строки, ``a`` становится равно 8, это уже
больше чем ``n``, поэтому внешний цикл закончился.

Цикл for
--------

Цикл ``while`` работает тупо: проверяет условие и выполняет код, и так
пока условие не перестанет выполняться. Это позволяет реализовать
практически любые правила зацикленности, какие нужны в задаче, и потому
часто применяется.

Но кроме того, довольно часто бывает так, что надо выполнить один и тот
же код несколько раз подряд, просто изменяя значения одной переменной
некоторым очень простым образом. Для этого есть цикл ``for``. Он пишется
так:

::

    for переменная in список_значений:
        код

Этот цикл работает так: указанной переменной присваивается первое
значение из списка, и выполняется код. Потом ей присваивается следующее
значение, и так далее.

Пример:

::

    for i in 7, 42, 137:
        print(i)

Этот код выведет на экран по очереди все три указанных числа (7, 42 и
137).

Список значений можно задавать как в примере выше, через запятую, а
можно и разными другими способами. Общие правила тут вы узнаете позже,
пока просто приведу наиболее распространенный вариант, который вам
сейчас чаще всего будет нужен (а вариант с явным перечислением значений,
как выше, вам сейчас довольно редко будет нужен).

А именно, очень часто вам надо, чтобы переменная цикла менялась,
перебирая числа в некотором диапазоне по порядку, например, 1, 2, 3, 4,
..., 10. Для этого есть конструкция ``range``. Пишется так:
``for i in range(1, 11)`` — это перебирает все числа от 1 (включительно)
до 11 (**невключительно**), т.е. как раз написанный выше набор чисел.
Еще раз, потому что важно: первое число включительно, второе
невключительно. Пример:

::

    for i in range(1, 21):
        print(i, "*", i, "=", i * i)

выводит на экран таблицу квадратов всех чисел от 1 до 20 включительно
(или до 21 невключительно).

У команды ``range`` можно не указывать первый параметр, тогда он будет
считаться равным 0: ``for i in range(4)`` переберет числа 0, 1, 2, 3.
Это может показаться странным и непоследовательным, но в следующей теме
(про массивы) вы поймете, что это очень естественно.

И наоборот, у команды ``range`` можно указать третий параметр — шаг, с
которым будет меняться значение переменной. Например, ``range(1, 7, 2)``
обозначает "от 1 (включительно) до 7 (невключительно) с шагом 2", т.е.
дает числа 1, 3, 5. Или ``range(0, 100, 10)`` дает числа 0, 10, 20, 30,
..., 90.

Особое применение этого третьего параметра — это перебор чисел в
обратном порядке. ``range(10, 0, -1)`` дает 10, 9, 8, ..., 1. Обратите
внимание, что 0 опять не включается. (Аналогично можно указывать шаг -2
и т.п.)

В ``range`` можно, конечно, указывать и переменные, выражения и т.д.
Например, ``range(a - b, a + b + 1)`` перебирает числа от ``a-b`` до
``a+b`` включительно (до ``a+b+1`` невключительно).

И напоследок — еще один, более сложный, пример применения цикла ``for``:

::

    for i in range(1, 10):
        for j in range(1, 10):
            print(i * j, end="")
        print()

выводит на экран таблицу умножения.

About break and continue statements
----------------------------

When working with loops, there are two useful statements — *break* and
*continue*. This is what they do and how to use them.

Definitions of the loop body and iteration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, I am introducing/restating a few terms that are useful when discussing
loops.

A **loop body** is essentially the combination of commands that are inside the
loop. For example, in this loop

::

    for i in range(1, n + 1):
        a = i * i
        print(i, a)


the loop body consists of two statements: assignment and output.

An **iteration** is an individual pass through the loop body. The loop
always repeats statements of the loop body several times — each such
repetition is what's called an iteration. In the example above, we can say that
the loop does *n* iterations. For instance, on the fifth
loop iteration, the string "5 25" would be displayed.

The break statement
~~~~~~~~~~~~~

The **break** statement stops the execution of the loop and signals to proceed
executing statements that come after the loop body. So if you decide
that at some particular moment you don't need to keep looping, the loop had done
everything you wanted it to, and you need to jump to what's below the body,
put ``break`` there. If a break happens in the middle of an iteration,
that iteration is aborted — the rest of the loop body will not be executed.

An example:

::

    for i in range(2, n + 1):
        if n % i == 0:
            print(i)
            break
        print('Tested', i, ', does not match')
    print('The end!')

— as soon as *if*'s condition becomes true, the corresponding *i* value
is printed, the loop execution is aborted, and after that "The end!" string
is printed. Notice that the string "Tested..." would be printed
for each *i* value, **not** including the one by which the condition became
true.

For instance, with ``n==9``, the following would be printed:

::

    Tested 2 , does not match
    3
    The end!

(In reality, this code could be made simpler by using *while* loops —
try to figure out how)

The *break* statement can be used with *while* and *repeat* loops as well,
an example is provided further below.

Команда continue
~~~~~~~~~~~~~~~~

Команда continue обозначает прервать выполнение текущей итерации цикла и
начать следующую итерацию. Т.е. как будто бы, не доделывая то, что
написано ниже в теле цикла, прыгнуть на начало цикла, при этом выполнив
все действия, которые должны быть выполнены после очередной итерации —
т.е. в цикле for увеличив значение счетчика цикла на 1, а в циклах
while/repeat проверив условие и, если оно не выполняется, то вообще
прервав работу.

Пример:

::

    for i in range(2, n):
        if n % i != 0:
            print('Попробовали', i, ', не подходит')
            continue
        print(n, 'делится на', i)

— здесь цикл пройдется по всем числам от ``2`` до ``n-1`` и для каждого выведет,
делится ли ``n`` на ``i`` или нет. Например, при ``n==9`` вывод будет такой:

::

    Попробовали 2 , не подходит
    9 делится на 3
    Попробовали 4 , не подходит
    ...
    Попробовали 8 , не подходит

Пройдем подробнее по началу выполнения этого кода. Сначала i становится
равным 2. Смотрим: ``9 % 2 != 0`` — значит, идем внутрь if. Выводим на
экран "Попробовали...", и далее идет команда continue. Значит, сразу
идем на следующую итерацию: увеличиваем ``i`` (!), оно становится равным 3,
и идем на начало цикла. ``9 % 3 == 0``, поэтому в if не идем, выводим "9
делится на 3", итерация закончилась — увеличиваем ``i`` и идем на следующую
итерацию. И так далее.

Конечно, в этом примере можно было бы обойтись и без ``continue``, просто
написать ``else``. Это было бы проще. Но бывает, что вам надо перебрать
числа, и есть много случаев, когда какое-то число вам не надо
рассматривать. Тогда писать кучу ``else`` было бы намного сложнее, чем
несколько ``continue``. Например (пример выдуман из головы, но подобные
случаи бывают):

::

    for i in range(n):
        # нам не нужны числа, делящиеся на 5
        if i % 5 == 0:
            continue
        # нам не нужны числа, квадрат которых дает остаток 4 при делении на 7
        # обратите внимание, что мы можем делать какие-то действия до проверки условий
        p = i * i
        if p % 7 == 4:
            continue
        # все оставшиеся числа нам нужны,
        # поэтому здесь делаем какую-нибудь сложную обработку из многих команд
        ...

— тут намного более понятно, что вы имели в виду, чем если бы вы писали
с ``else``. С ``else`` тому, кто будет читать ваш код, пришлось бы смотреть, где
``else`` заканчивается, и вдруг после конца ``else`` идут еще какие-нибудь
команды, а здесь все понятно: если ``if`` выполняется, то пропускается все
оставшееся тело цикла.

while True и break
~~~~~~~~~~~~~~~~~~~~~

Один важный случай применения команды ``break`` состоит в следующем. Часто
бывает так, что вам надо повторять какую-то последовательность действий,
и проверять условие окончания вам хочется в середине этой
последовательности. Например, вам надо считывать с клавиатуры числа,
пока не будет введен ноль. Все числа, кроме нуля, надо как-то
обрабатывать (для простоты будем считать, что выводить на экран — это
нам не существенно).

Естественная последовательность действий следующая:

::

    считать число
    если ноль, то прерваться
    вывести это число на экран
    считать число
    если ноль, то прерваться
    вывести это число на экран
    ...

Очень четко видна цикличность, но если вы попытаетесь написать цикл без
команды ``break``, ничего хорошего у вас не получится.

У вас будет несколько вариантов: например, так

::

    a = int(input())
    while a != 0:
        print(a)
        a = int(input())

Фактически вы "разрезали" циклическую последовательность действий на
проверке условия окончания цикла, и в результате были вынуждены команду
считывания числа задублировать: она у вас один раз перед циклом, и один
раз в конце цикла. Дублирование кода — это не очень хорошо (если вам
придется его менять, вы можете забыть, что один и тот же код в двух
местах); если у вас вместо считывания числа будет чуть более сложный
код, то будет еще хуже. Кроме того, в этой реализации не очень хорошо,
что у вас в пределах одной итерации цикла есть разные значения
переменной ``a``, было бы проще, если бы каждая итерация цикла
соответствовала работе только с одним введенным числом.

Второй вариант, который вам может придти в голову, такой:

::

    a = 1
    while a != 0:
        a = int(input())
        if a != 0:
            print(a)

Этот вариант лучше в том смысле, что каждая итерация работает только с
одним числом, но у него все равно есть недостатки. Во-первых, есть
искуственная команда ``a = 1`` перед циклом. Во-вторых, условие ``a != 0``
дублируется; если вам придется его менять, вы можете забыть, что оно
написано в двух местах. В-третьих, у вас *основная* ветка выполнения
цикла, ветка, по которой будет выполняться большинство итераций, попала
в ``if``. Это не очень удобно с точки зрения кода: все-таки все числа, кроме
последнего, будут не нулевыми, поэтому хотелось бы написать такой код, в
котором обработка случая ``a = 0`` не потребует заворачивания основного
варианта в ``if`` — так просто читать удобнее (особенно если бы у нас было
бы не просто ``print(a)``, а существенно более сложный код обработки
очередного числа, сам включающий несколько ``if``'ов и т.п.).

Но можно сделать следующим образом:

::

    while 0 == 0:
        a = int(input())
        if a == 0:
            break
        print(a)

Искусственная конструкция ``0==0`` — это условие, которое всегда верно: нам
надо, чтобы ``while`` выполнялся до бесконечности, и мог бы завершиться
только по ``break``. На самом деле в питоне есть специальное слово ``True``,
которое обозначает условие, которое всегда верно (и симметричное слово
``False``, которое обозначает условие, которое не верно никогда).
Соответственно, еще лучше писать ``while True:``...

Этот вариант свободен от всех указанных выше недостатков. Каждая
итерация работает с очередным числом, код считывания не дублируется, код
проверки не дублируется, общая последовательность действий понятна, и
основная ветка выполнения цикла находится в основном коде.

Вот так и следует писать любые циклы, в которых проверка условия нужна
*в середине* тела цикла:

::

    while True:
        что-то сделали
        if надо завершить работу:
            break
        сделали что-то еще

Примеры решения задач
---------------------

Приведу несколько примеров задач, аналогичных тем, которые встречаются на олимпиадах
и в моем курсе.

.. task::

    В классе :math:`N` школьников. На уроке физкультуры тренер говорит «на первый-второй рассчитайтесь».
    Выведите, что скажут ученики.

    **Входные данные**: Вводится одно целое число — количество человек в классе.

    **Входные данные**: Выведите последовательность чисел 1 и 2, в том порядке, как будут говорить школьники.

    **Пример**:

    Входные данные::

        5

    Выходные данные::

        1
        2
        1
        2
        1
    |
    |
    |

Сначала, конечно, считываем :math:`N`::

    n = int(input())

Самое главное в задачах на циклы — понять, какая операция будет повторяться, и сколько раз или до какого условия,
и чему будет соответствовать каждое повторение (итерация) цикла.
В этой задаче более-менее понятно: надо :math:`N` раз вывести число, и каждая итерация
будет соответствовать одному школьнику. Поэтому логично написать цикл ``for i in range(n)``,
он как раз осуществит :math:`N` повторений.

Дальше надо понять, что делать внутри каждого повторения. Здесь надо решить, что выводить — 1 или 2 —
и соответственно вывести. В цикле ``for`` у нас как раз есть переменная ``i``, которая хранит номер текущего школьника.
(Это очень важный момент — внутри цикла вы должны писать общий код, который будет работать
в общем виде на каждой итерации, и обычно как раз стоит опираться на какие-то переменные,
отражающие текущее состояние, в цикле ``for`` это обычно переменная цикла.)

Ясно, что число, которое надо вывести, зависит от четности ``i``. Надо еще учесть,
что итерация цикла (``range(n)``) начинается с нуля, поэтому общий код получается такой::

    n = int(input())
    for i in range(n):
        if i % 2 == 0:
            print(1)
        else:
            print(2)

.. task::

    Вводятся :math:`N` чисел. Посчитайте, сколько среди них четных.

    **Входные данные**: На первой строке вводится одно число :math:`N`. Далее следуют :math:`N` строк по одному числу на каждой — заданные числа.

    **Входные данные**: Выведите ответ на задачу.

    **Пример**:

    Входные данные::

        4
        10
        11
        12
        13

    Выходные данные::

        2
    |
    |
    |

Здесь вы сталкиваетесь с тем, что заранее (на этапе написания программы) вы не знаете, сколько чисел надо будет вводить.
Вы должны сначала ввести число :math:`N`, а потом еще :math:`N` чисел, т.е. если вам первым числом вводят 3, значит, дальше будет еще 3 числа,
а если первым числом вводят 137, то дальше будет еще 137 чисел. Это радикально отличается от того, что вы делали раньше,
когда вы знали, например, что всегда вводится ровно 6 чисел.

Но как раз циклы и позволяют повторить некоторую операцию заданное число раз, причем на этапе написания программы
вам не обязательно знать, сколько раз надо это делать. В примере выше внутри цикла вы выводили данные,
а тут по смыслу задачи внутри цикла вам придется *считывать* данные.

Вы считываете сначала :math:`N`::

    n = int(input())

а дальше вам надо написать цикл, повторяющийся :math:`N` раз, и внутри цикла считывать числа::

    for i in range(n):
        x = int(input())
        ...

Дальше надо у каждого числа проверить, четное ли оно: ``if x % 2 == 0``, ну и если четное, то увеличить счетчик четных чисел на единицу.
Такой счетчик, естественно, надо завести заранее. 

Итого получаем::

    n = int(input())
    k = 0
    for i in range(n):
        x = int(input())
        if x % 2 == 0:
            k += 1
    print(k)

Обратите внимание, что вывод ответа (``k``) надо делать после окончания цикла, поэтому команда ``print`` пишется без отступа.

.. task::

    Посчитайте сумму :math:`1+2+3+\ldots+N`.

    **Входные данные**: Вводится одно целое число :math:`N`.

    **Входные данные**: Выведите искомую сумму.

    **Пример**:

    Входные данные::

        2

    Выходные данные::

        3

    Входные данные::

        5

    Выходные данные::

        15
    |
    |
    |

(Конечно, эту задачу можно решить известной формулой,
но давайте все-таки напишем цикл.)

(Обратите еще внимание, что ввод 2 корректен, и ответ на 2 равен 3, несмотря на то, что в формуле написана и двойка, и тройка, и :math:`N`.
Это стандартная особенность таких математических обозначений: в формуле с многоточием пишется побольше слагаемых,
чтобы была понятна логика, но если :math:`N` маленькое, то просто остается только столько слагаемых, сколько надо.)

В такой задаче полезно подумать, как бы вы считали ответ вручную.
Часто говорят: сложил бы все числа.
Но если подумать, вы же не сможете сложить сразу все пять чисел.
Вы наверняка будете складывать числа по очереди:
сначала к 1 прибавляете 2, потом к результату прибавляете 3,
потом к результату прибавляете 4, и т.д.

Соответственно, какая картина вырисовывается: у вас много раз повторяется
одно и то же действие: к текущей сумме прибавить очередное число. Значит, нам, во-первых,
явно нужен цикл, перебирающий числа подряд, во-вторых, нам явно нужна
переменная для текущей суммы, пусть это будет переменная :math:`k`. 
Соответственно, получается что-то такого рода::

    for i in .....:
        ... k + i

т.е. вам надо к :math:`k` прибавить :math:`i`.
Но просто так прибавлять смысла нет, надо куда-нибудь сохранить результат.
И тут фокус, возможно, не очень очевидный: результат надо сохранять в :math:`k`!
Потому что на следующей итерации цикла именно к этому результату
надо будет прибавлять следующее :math:`i`::

    for i in .....:
        k = k + i

осталось понять, в каких пределах надо запускать цикл, а также что изначально записать в :math:`k`.
Напрашивается решение в :math:`k` записать 1 (первое слагаемое), а цикл делать от 2 до :math:`N`,
но на самом деле немного проще изначально в :math:`k` записать 0 (пустую сумму, т.е. как будто нет слагаемых вообще),
а цикл делать от 1 до :math:`N`, причем, естественно, :math:`N` включительно, поэтому надо писать ``range(1, n + 1)``.

Итоговый код, вместе с вводом и выводом переменных::

    n = int(input())
    k = 0
    for i in range(1, n + 1):
        k = k + i
    print(k)
    
.. task::

    Маша хочет накопить на новый телефон. Телефон стоит :math:`N` рублей.
    Маша может откладывать :math:`K` рублей в день каждый день, за исключением воскресенья,
    когда она тратит деньги на поход в кино.
    Маша начинает копить в понедельник. За сколько дней она накопит нужную сумму?

    **Входные данные**: Вводятся два числа: :math:`N` и :math:`K`.

    **Входные данные**: Выведите искомое количество дней

    **Пример**:

    Входные данные::

        100 50

    Выходные данные::

        2

    Входные данные::

        100 10

    Выходные данные::

        11
    |
    |
    |

В принципе, эту задачу не так уж и сложно решить формулой, без циклов (но скорее всего с if'ами),
но давайте напишем цикл.

Попробуем промоделировать, как будет увеличиваться сумма накопленных денег у Маши. Обозначим текущую сумму как :math:`s`.
Каждый день, кроме воскресенья, к ней прибавляется :math:`K`.
Логично написать цикл, чтобы одна итерация цикла соответствовала одному дню.
Цикл надо продолжать до тех пор, пока не накопится нужная сумма, поэтому естественно написать цикл ``while``::

    while s < n:

Что мы делаем в цикле? Надо прибавить :math:`K` к :math:`s`, но только если текущий день не воскресенье::

    while s < n:
        if .....:  # тут надо написать условие «не воскресенье»
            s = s + k

Как понять, воскресенье сейчас или нет? Естественно, нам нужен какой-нибудь счетчик дней, заодно он нам нужен будет
и для вывода ответа. Заводим переменную :math:`day` — номер текущего дня. Маша начинает копить в понедельник,
считая это днем 1, понимаем, что воскресенья — это дни, номера которых делятся на 7.

Получаем примерно такой код::

    day = 1
    s = 0
    while s < n:
        if day % 7 != 0:
            s = s + k
        day = day + 1

Тут единственная проблема — мы заканчиваем цикл, уже перейдя к очередному дню, т.е. в этом коде :math:`day`
получается всегда на 1 больше, чем нужно. Поэтому при выводе ответа надо вычесть единицу::

    n, k = map(int, input().split())
    day = 1
    s = 0
    while s < n:
        if day % 7 != 0:
            s = s + k
        day = day + 1
    print(day - 1)